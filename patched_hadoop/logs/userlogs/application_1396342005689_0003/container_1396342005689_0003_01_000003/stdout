FORMATTED QUERY:SELECT key_validator,       key_aliases,       column_aliases FROM system.schema_columnfamilies WHERE keyspace_name='cql3_worldcount' and columnfamily_name='output_words'
-----------------------------Printing keys to initialize partitionkeycolumns---cqlrecwriter:402
Key: row_id1
Reduce Setup : PartitionKey[0]: word
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :If
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :If
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: If
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :If
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: If
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: If
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :can
-----print keycolumns-----
--------------------------prepared statment start
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :can
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: can
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :can
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: can
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: can
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :head
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :head
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: head
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :head
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: head
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: head
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :keep
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :keep
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: keep
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :keep
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: keep
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: keep
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :you
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :you
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: you
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :you
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: you
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: you
-----print keycolumns(before calling ringcache)-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :your
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :your
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: your
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
-----print keycolumns-----
Key : row_id1 Val: :word
Key : row_id2 Val: :sum
Key : word Val: :your
Bytebuffer: word
Bytebuffer: sum
Bytebuffer: your
PartitionKeyCol:row_id1
KeyCols:[row_id1, row_id2, word]
--------------------------Getting token for a key
Key:word
--------------------------Populating put requests:Partition
KEY: row_id1 keyColumns.get: word
--------------------------Populating put requests:Cluster
KEY: word keyColumns.get: your
--------------------------prepared statment start
--------------------------arg buffer start
Contents:34
Contents:word
Contents:can
--------------------------arg buffer start
Contents:34
Contents:word
Contents:head
--------------------------arg buffer start
Contents:34
Contents:word
Contents:keep
--------------------------arg buffer start
Contents:34
Contents:word
Contents:you
--------------------------arg buffer start
Contents:34
Contents:word
Contents:your
cql: UPDATE cql3_worldcount.output_words SET count_num = ? WHERE "row_id1" = ? AND "word" = ?
--------------------------prepared statment done
end queue:[[java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4], java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]], [java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4]], [java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4]], [java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4], java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]], [java.nio.HeapByteBuffer[pos=0 lim=2 cap=2], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4], java.nio.HeapByteBuffer[pos=0 lim=4 cap=4]]]
